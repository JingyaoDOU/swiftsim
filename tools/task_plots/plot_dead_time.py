#!/usr/bin/env python
"""
Usage:
    python plot_dead_time.py --input-files FILE_PATTERN \
      --output OUTPUT_FILE_NAME --task-labels FILE_CONTAINING_TASK_LABELS \
      --subtask-labels FILE_CONTAINING_SUBTASK_LABELS \
      [--limit MINIMUM_FRACTION_FOR_OUTPUT]

where FILE_PATTERN should match at least one file containing dead time 
statistics (output by SWIFT as dead_time-step*.dat) and the TASK_LABEL and
SUBTASK_LABEL file names should match the files containing string labels for
task types and subtypes respectively (output by SWIFT as 
task_labels_task_types.txt and task_labels_task_subtypes.txt). OUTPUT_FILE_NAME
should end with a Matplotlib compatible image file extension (e.g. ".png").

Description:
Reads in the dead-time statistics files generated by SWIFT and produces a
horizontal bar diagram quantifying how much dead time is caused by the various
tasks that were run. Any number (at least one) of input files can be specified.
The numbers shown accumulate the contributions over all the input files.

The optional argument "--limit" can be used to limit the output to tasks that
cause at least the given fraction of the total dead-time.

This file is part of SWIFT.

Copyright (C) 2021 Bert Vandenbroucke (vandenbroucke@strw.leidenuniv.nl)
All Rights Reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""


import numpy as np
import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as pl
import argparse
import re

# parse command line arguments
argparser = argparse.ArgumentParser("Parse SWIFT dead-time statistics files.")
argparser.add_argument(
    "--input-files",
    "-i",
    action="store",
    nargs="+",
    required=True,
    help="List of input files containing dead-time statistics.",
)
argparser.add_argument(
    "--output",
    "-o",
    action="store",
    required=True,
    help="Output file name. Should end with a Matplotlib compatible image file "
    "extension.",
)
argparser.add_argument(
    "--task-labels",
    "-t",
    action="store",
    required=True,
    help="Name of the file that contains task type labels.",
)
argparser.add_argument(
    "--subtask-labels",
    "-s",
    action="store",
    required=True,
    help="Name of the file that contains task subtype labels.",
)
argparser.add_argument(
    "--limit",
    "-l",
    action="store",
    type=float,
    default=0.0,
    help="Minimum dead-time fraction a task needs to cause to be included in "
    "the output.",
)
args = argparser.parse_args()

tasks = np.loadtxt(
    args.task_labels,
    dtype={"names": ("idx", "name"), "formats": ("i", "U200")},
)
subtasks = np.loadtxt(
    args.subtask_labels,
    dtype={"names": ("idx", "name"), "formats": ("i", "U200")},
)


# tasks and subtasks are not dictionaries, so we need an auxiliary function
# to use them as such
def get_name(idx, names):
    return names[names["idx"] == idx][0]["name"]


# auxiliary function that extracts the number count from a file name
def getcount(filename):
    return int(re.findall("\d+", filename)[0])


# sort the input files on their counter (accounting for missing padding that
# messes up a lexicographical sort)
files = sorted(args.input_files, key=getcount)


# create a nice title label that lists the input files in a compact format,
# accounting for ranges of successive files and indices missing from these
# ranges
#
# a single input file with number 2 will result in a label: "step 2"
# a wildcard range matching 10 succesive files (1 to 10) will result in
# "step 1-10"
# a complex range matching the files with numbers 2, 5, 10, 11, 12, 13 will
# result in "step 2, 5, 10-13"
#
# the label also contains statistics about the dead time itself
def get_title(names, time_w_pure, time_n_pure, time_all):
    imin = getcount(names[0])
    title = "step {0}".format(imin)
    iprev = imin
    for i in range(1, len(names)):
        inext = getcount(names[i])
        if not inext == iprev + 1:
            if iprev == imin:
                title += ", {0}".format(inext)
                imin = inext
            else:
                title += "-{0}, {1}".format(iprev, inext)
                imin = inext
        iprev = inext
    if not imin == iprev:
        title += "-{0}".format(inext)
    title += "\nfraction of dead time: {0:.2g}".format(time_w_pure / time_all)
    title += "\nfraction of pure dead time: {0:.2g}".format(
        (time_w_pure - time_n_pure) / time_w_pure
    )
    return title


# produce a dictionary with accumulated dead time for each task
stats = {}
# also accumulate the total dead time, with and without pure dead time
total_w_pure = 0.0
total_n_pure = 0.0
total_all = 0.0
for file in files:
    data = np.loadtxt(
        file,
        usecols=(0, 1, 2),
        dtype={
            "names": ("type", "subtype", "dead_time"),
            "formats": ("i", "i", "d"),
        },
    )
    # extract the first two lines that do not contain task output
    total_all += data[0]["dead_time"]
    total_w_pure += data[1]["dead_time"]
    total_n_pure += data[1]["dead_time"] - data[2]["dead_time"]
    # drop the final line that only contains task totals
    others = data[3:-1]
    # now parse the actual tasks
    for task in others:
        # compose the task name: {type_name}_{subtype_name}
        name = "{0}_{1}".format(
            get_name(task["type"], tasks), get_name(task["subtype"], subtasks)
        )
        if name in stats:
            # accumulate if we already have an entry
            stats[name] += task["dead_time"]
        else:
            # create an entry if we don't
            stats[name] = task["dead_time"]

# create the horizontal bar plot
fractions = []
labels = []
for task in stats:
    fraction = stats[task] / total_n_pure
    # apply the limit
    if fraction >= args.limit:
        labels.append(task)
        fractions.append(fraction)
pl.barh(np.arange(len(fractions)), fractions, tick_label=labels)
pl.gca().set_xscale("log")
pl.xlabel("dead time fraction caused by task")
pl.title(get_title(files, total_w_pure, total_n_pure, total_all))

pl.tight_layout()
pl.savefig(args.output, dpi=300)
